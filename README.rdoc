= Message Router

Message router is a DSL for routing and processing simple messages, like SMS messages or Tweets.

== Installation

    sudo gem install message_router

== Example Code

See rdoc for MessageRouter::Router.build (lib/message_router/router.rb) for examples.

And now some irb action.

    1.8.7 :001 > class HelloRouter < MessageRouter::Router
    1.8.7 :002?>     match /hi/ do |msg|
    1.8.7 :003 >           puts "Hi there. You sent me: #{msg.inspect}"
    1.8.7 :004?>         true # puts returns nil, and that would fail the matcher
    1.8.7 :005?>       end
    1.8.7 :006?>   end
     => [[/hi/, #<Proc:0x00000000026963b8@(irb):2>]] 
    1.8.7 :007 > HelloRouter.new.call({'body' => 'can you say hi to me?'})
    Hi there. You sent me: {'body'=>"can you say hi to me?"}
     => true 
    1.8.7 :008 > class MainRouter < MessageRouter::Router
    1.8.7 :009?>     match({'to' => 'greeter'}, HelloRouter.new)
    1.8.7 :010?>     match(true) do
    1.8.7 :011 >           puts "WTF? I don't know how to do that!"
    1.8.7 :012?>         true # puts returns nil, and that would fail the matcher
    1.8.7 :013?>       end
    1.8.7 :014?>   end
     => [[{:to=>"greeter"}, #<HelloRouter:0x25fef90 @rules=[[#<Proc:0x000000000266b2d0@/home/paul/sc/pe/message_router/lib/message_router/router.rb:165>, #<Proc:0x00000000026963b8@(irb):2>]]>], [true, #<Proc:0x00000000025ff580@(irb):10>]] 
    1.8.7 :015 > MainRouter.new.call({'body' => 'can you say hi to me?'})
    WTF? I don't know how to do that!
     => true 
    1.8.7 :016 > MainRouter.new.call({'body' => 'can you say hi to me?', 'to' => 'greeter'})
    Hi there. You sent me: {'body'=>"can you say hi to me?", 'to'=>"greeter"}
     => true 


== TODO

Get docs working nicely (formatting, etc.) with RDoc.

Add tests to ensure that instance variables can be shared between initializers and helpers. For example:
    class MyRouter < MessageRouter::Router
      def initilaize(config)
        @sender = config[:sender]
        super
      end

      match true do
        send_something
      end

      def send_something
        @sender.puts 'something'
      end
    end
    MyRouter.new(:sender => STDOUT).call({})  # prints out 'something' to standard out.

Pass Regexp captures on to the proc when there is a match. Examples:
    match /some (cool|awesome) thing/ do |env, match|
      puts "You thought the thing was #{match[1]}"
    end
    match 'some_attr' => /some (cool|awesome) thing/, 'body' => /(.*)/ do |env, matches|
      puts "You thought that #{matches['body'][1]} was #{matches['some_attr'][1]}"
    end
    -- OR --
    match /some (cool|awesome) thing/ do |env|
      puts "You thought the thing was #{env['message_router_match'][1]}"
    end
    match 'some_attr' => /some (cool|awesome) thing/, 'body' => /(.*)/ do |env|
      puts "You thought that #{env['message_router_matches']['body'][1]} was #{env['message_router_matches']['some_attr'][1]}"
    end
    -- OR -- (probably best because it is simplest)
    match /some (cool|awesome) thing(.*)/ do |env, word, the_rest|
      puts "You thought the thing was #{word}. But the rest is #{the_rest}"
    end
    match 'some_attr' => /some (cool|awesome) thing(.*)/, 'body' => /(.*)/ do |env, hash|
      puts "You thought that #{hash['body']} was #{hash['some_attr'][0]}. But the rest is #{hash['some_attr'][1]}"
    end
    -- OR -- (if the note below about setting context/scope of annonymous functions is done)
    match /some (cool|awesome) thing(.*)/ do |word, the_rest|
      puts "You thought the thing was #{word}. But the rest is #{the_rest}"
    end
    match 'some_attr' => /some (cool|awesome) thing(.*)/, 'body' => /(.*)/ do |hash|
      puts "You thought that #{hash['body']} was #{hash['some_attr'][0]}. But the rest is #{hash['some_attr'][1]}"
    end

Improve specs to minimize use of global variables. The idea below about passing copies of the message around (instead of modifying it in place) might help here. I could have various bits of code being tested modify the message, and the final return value would be the message, which I could examine.

Consider making the String matcher more flexible. There could be options for:
* Exact match
* Case sensitivity
* Partial matches:
  * starts with
  * ends with
  * contains

Recursion detection: It could be done by having a specific key in the message hash for parents. Before sending #call to a matcher's proc we could run something like "message['message_router_stack'] << self". Then we could check the size of this. The maximum number of levels would need to be configurable to allow some recursion.
* We could just rely on a stack overflow, but having recursion detection would make debugging easier.

Make helper methods defined (or included) in parent routers available in sub routers. It could be done with delegation, but that might get messy. It may be easier to not implement this and just require the user to use sub-classing to get the desired behavior.

Pass around copies of the message Hash instead of modifying the existing Hash in place.
* This _might_ help with multi-threading
  * Perhaps a parent router wants to delegate to 2 sub-routers which are independent of each other. The current implementation has a shared message object, so I couldn't use multi-threading, (though forking could work). I would have to trust the user to call #dup on at least one of the messages. With this new way, it is safe by default.
* Convention would be for the 'should_i' Procs to return a copy of the message, either modified or not, depending on their needs.
  * They would still return nil or false if they don't match.
* We could also require (by convention only) that sub-routers also return a copy of the message (if they succeed) so this (optionally modified) message can be used for further routing.
  * This would give the original router access to both the modified message and the original message.

It might be nice to have the message available as an instance variable/method. Currently the message can only be passed as an argument to the proc because there is just 1 instance of the router which is used over and over again. If the router was a class and we instantiated a new instance of that class for each message, then this feature would probably be easy.

Add #env helper which is the environment (aka the message). It should be accessible from any user-defined helpers.

If the 2nd argument to #match is an anonymous function (lambda, proc, or block), then execute it in the context/scope of the matcher so it has access to all helpers (user-defined and those provided by MessageRouter) and don't pass the env Hash as an argument (since it is available as a helper). If the 2nd argument to #match is simply an object that responds to call, then just call #call(env) and don't mess with context/scope (as we do now).
* After doing this, we no longer need to pass the env Hash to helper methods.
* IMPORTANT: If we do this, users need to be careful about instance variables. Instance variables are owned by the router, not the message, so they are essentially global variables. Users should never use instance variables in helpers. Instead any extra state should be stored in the env Hash because MessageRouter will clear that away between messages.

== License

Copyright (c) 2009-2012, Brad Gessler

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
